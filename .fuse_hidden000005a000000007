/// <reference path="jquery.d.ts"/>

var DEFAULT_LENGTH:number = 5;
var DIRECTIONS:any = {
	"UP":38,
	"DOWN":40,
	"LEFT":37,
	"RIGHT":39
}
var SNAKE_BLOCK_BASE:number = window.innerWidth;
var SNAKE_BLOCK_SIDE:number = 12;

var MOVE_UNIT:number = window.innerWidth/(SNAKE_BLOCK_BASE*12);
interface Drawable {
	context:any;
	render:() => void;
}

interface CoordinatePair {
	x:number;
	y:number;
}

class SnakeComponent implements Drawable {
	direction:number;
	constructor(public context, public x:number, public y:number, public color?:string) {
		if (!this.color) {
			this.color = "white";
		}
	}
	setCoords(x:number, y:number) {
		this.x = x;
		this.y = y;
	}
	getCoords() {
		return {x:this.x, y:this.y};
	}
	move() {
		if (this.direction == DIRECTIONS.UP) {
			this.y -= MOVE_UNIT;
		}
		else if (this.direction == DIRECTIONS.DOWN) {
			this.y += MOVE_UNIT;
		}
		else if (this.direction == DIRECTIONS.LEFT) {
			this.x -= MOVE_UNIT;
		}
		else {
			this.x += MOVE_UNIT;
		}
	}
	render() {
		this.context.fillStyle = this.color;
		this.context.fillRect(this.x, this.y, SNAKE_BLOCK_BASE, SNAKE_BLOCK_BASE);
	}
}

class Snake implements Drawable {
	length:number=DEFAULT_LENGTH;
	x:number;
	y:number;
	direction:number=DIRECTIONS.RIGHT;
	totalLength:number;
	components:Array<SnakeComponent>;
	constructor(public context:any, public isAI:boolean){
		if (!this.isAI) {
			this.x = 0;
			this.y = 0;
		}
		this.totalLength = this.calculateTotalLength();
		
		this.components = [];
		for (var i=0;i<this.length;i++) {
			this.components.push(new SnakeComponent(this.context, i*(SNAKE_BLOCK_SIDE), 0));
		}
	}
	calculateTotalLength() {
		return this.length * (SNAKE_BLOCK_SIDE);
	}
	render() {
		$.each(this.components, function(i:number, component:SnakeComponent) {
			component.render();
		});
	}
	setDirection(dir:number) {
		this.direction = dir;

	}
	willPassWall() {
		if (this.direction == DIRECTIONS.UP && this.y+this.totalLength+SNAKE_BLOCK_SIDE < 0) {
			return true;
		}
		else if (this.direction == DIRECTIONS.DOWN && this.y+this.totalLength+SNAKE_BLOCK_SIDE > window.innerHeight) {
			return true;
		}
		else if (this.direction == DIRECTIONS.LEFT && this.x-SNAKE_BLOCK_SIDE < 0) {
			return true;
		}
		else if (this.direction == DIRECTIONS.RIGHT && this.x+this.totalLength+SNAKE_BLOCK_SIDE > window.innerWidth) {
			return true;
		}
		else {
			return false;
		}
	}
	move(coords?:CoordinatePair) {
		var changedDirection:boolean = false;
		$.each(this.components, function(i:number, component) {
			if (i == 0 && component.direction != this.direction) {
				component.direction = this.direction;
				changedDirection = true;
			}
			else if (i != 0 && component.direction != this.components[i-1] && !changedDirection) {
				component.direction = this.components[i-1];
				changedDirection = true;
			}
			component.move();
		}.bind(this));
		if (coords) {
			this.x = coords.x;
			this.y = coords.y;
		}
		else {
		}
	}
}

class SnakeGame {
	canvas:HTMLElement;
	context:any;
	human:Snake;
	players:Array<Snake>;
	constructor() {
		this.canvas = $("canvas")[0];
		this.context = this.canvas.getContext("2d");
		this.human = new Snake(this.context, false);
		this.players = [this.human];
		$(document.body).keydown(this.handleKeydown.bind(this));
		this.render();
	}
	handleKeydown(e:JQueryKeyEventObject) {
		this.human.setDirection(e.keyCode);
	}
	render() {
		this.canvas.width = window.innerWidth;
		this.canvas.height = window.innerHeight;
		this.context.clearRect(0, 0, window.innerWidth, window.innerHeight);
		this.context.fillStyle = "black";
		this.context.fillRect(0, 0, window.innerWidth, window.innerHeight);

		for (var i in this.players) {
			this.players[i].move();
			this.players[i].render();
		}
		if (this.human.willPassWall()) {
			return false;
		}
		window.setTimeout(function() {
			window.requestAnimationFrame(this.render.bind(this))
		}.bind(this), 200);
	}
}

$(document).ready(function() {
	var game = new SnakeGame();
})